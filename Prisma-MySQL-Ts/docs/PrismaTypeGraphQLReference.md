# prisma & type-graphql

## (1) Generate a physical schema file. 

We can add `emitSchemaFile: true` in `buildSchemaSync()` in `index.ts`.

## (2) Generate a models in the custom folder.

We could have an output option in `schema.prisma`

```
generator typegraphql {
  provider = "typegraphql-prisma"
}
```

## (3) Related object does not get reflected with typegraphql-prisma

**Solutions**

1. Create a custom model and use it.

2. Import relation Resolver from generated resolver.

```typescript
import { NonEmptyArray } from 'type-graphql';
import { BookResolver } from './BookResolver';
import { AuthorResolver } from './AuthorResolver';
import { BookRelationsResolver, AuthorRelationsResolver } from '@generated/type-graphql';

export const resolvers: NonEmptyArray<Function> = [
  BookResolver,
  BookRelationsResolver,
  AuthorResolver,
  AuthorRelationsResolver
];
```

When using the generated resolvers, you have to first provide the PrismaClient instance into the context under prisma key, to make it available for the crud and relations resolvers:

```TypeScript
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

const server = new ApolloServer({
  schema, // from previous step
  playground: true,
  context: (): Context => ({ prisma }),
});
```

**Issue Details**

We have two tables. 

```
model book {
  id       Int    @id @default(autoincrement())
  title    String
  authorId Int
  author   author @relation(fields: [authorId], references: [id])
}

model author {
  id   Int    @id @default(autoincrement())
  name String
  book book[]
}
```

This only generates raw fields. Not the field from the relationship.

```ts
@TypeGraphQL.ObjectType({
  isAbstract: true
})
export class Author {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
  id!: number;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  name!: string;

  book?: Book[];
}

@TypeGraphQL.ObjectType({
  isAbstract: true
})
export class Book {
  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
  id!: number;

  @TypeGraphQL.Field(_type => String, {
    nullable: false
  })
  title!: string;

  @TypeGraphQL.Field(_type => TypeGraphQL.Int, {
    nullable: false
  })
  authorId!: number;

  author?: Author;
}
```

So, if the resolver is using the model generated by typegraphql-prisma, this does not bring the data from the related table.

```typescript
import 'reflect-metadata';
import { Arg, Query, Resolver } from 'type-graphql';
import { Book } from '@generated/type-graphql';
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

@Resolver()
class BookResolver {
  @Query(() => [Book])
  async books() {
    return await prisma.book.findMany();
  }

  @Query(() => Book)
  async book(@Arg('id', () => Number) id: number) {
    return await prisma.book.findFirst({
      where: {
        id
      }
    });
  }
}

export default BookResolver;
```

`schema.gql` created by emitting the schema with type-graphql will look like this:

```graphql
type Book {
  authorId: Int!
  id: Int!
  title: String!
}

type Query {
  book(id: Float!): Book!
  books: [Book!]!
}
```


